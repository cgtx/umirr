import json
import six
import falcon
from .utils import calculate_distance


class SettingsResource:
    ''' Simple resources to expose application settings. '''
    def __init__(self, settings_data):
        self.settings_data = settings_data

    def on_get(self, req, resp):
        resp.status = falcon.HTTP_200
        resp.body = json.dumps(self.settings_data)


class MirrorsResource:
    ''' Simple resource to expose mirror data. '''
    def __init__(self, mirrors_data):
        for host in mirrors_data:
            del mirrors_data[host]['owner']
            del mirrors_data[host]['contact']
        self.clean_mirrors_data = mirrors_data

    def on_get(self, req, resp):
        resp.status = falcon.HTTP_200
        resp.body = json.dumps(self.clean_mirrors_data)


class MirrorListResource:
    ''' Generate list of mirrors relative to requestor's location. '''
    def __init__(self, settings_data, mirrors_data):
        self.settings_data = settings_data
        self.mirrors_data = {host: data
                             for host, data in six.iteritems(mirrors_data)
                             if data.get('enabled')}

    def find_mirrors(self, repo, arch, protocol, src):
        mirrorlist = []
        for host, data in six.iteritems(self.mirrors_data):
            resource = data.get('resources').get(protocol)
            if resource:
                dst = (data.get('coordinates').get('latitude'),
                       data.get('coordinates').get('longitude'))
                distance = calculate_distance(src, dst)
                path = self.settings_data.get('repos').get(repo)
                url = '{}://{}/{}/{}/'.format(protocol,
                                              host,
                                              resource.strip('/'),
                                              path.strip('/'))
                mirrorlist.append((distance,
                                   host,
                                   url.replace('@arch@', arch)))
        mirrorlist.sort()    
        return mirrorlist

    def on_get(self, req, resp):
        repo = req.get_param('repo', required=True)
        if repo not in self.settings_data.get('repos'):
            raise falcon.HTTPInvalidParam('({})'.format(repo), 'repo')
        arch = req.get_param('arch', required=True)
        if arch not in self.settings_data.get('arches'):
            raise falcon.HTTPInvalidParam('({})'.format(arch), 'arch')
        protocol = req.get_param('protocol') or 'http'
        if protocol not in self.settings_data.get('protocols'):
            raise falcon.HTTPInvalidParam('({})'.format(protocol), 'protocol')
        output = []
        if self.settings_data.get('app').get('show_header'):
            output.append('# mirrorlist generated by umirr')
            output.append('#')
        if self.settings_data.get('app').get('show_source'):
            msg = '# ordered for {}, {} {} ({})'
            source = req.get_header('X-Forwarded-For').split(',')[0]
            formatted = msg.format(req.get_header('X-Forwarded-For-City'),
                                   req.get_header('X-Forwarded-For-Region'),
                                   req.get_header('X-Forwarded-For-Country'),
                                   source)
            output.append(formatted)
            output.append('#')
        coordinates = (req.get_header('X-Forwarded-For-Latitude'),
                       req.get_header('X-Forwarded-For-Longitude'))
        mirrors = self.find_mirrors(repo, arch, protocol, coordinates)
        if self.settings_data.get('app').get('show_distances'):
            msg = ['# approximate distances:']
            urls = []
            for distance, host, url in mirrors:
                msg.append('#    {} - {} miles away'.format(host, distance))
                urls.append(url)
            output.extend(msg)
            output.append('#')
            output.extend(urls)
        else:
            for distance, host, url in mirrors:
                output.append(url)
        resp.status = falcon.HTTP_200
        resp.content_type = 'text/plain'
        resp.body = '\n'.join(output)
